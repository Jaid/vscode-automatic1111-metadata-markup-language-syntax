import path$1 from 'node:path';
import { fileURLToPath } from 'node:url';
import os from 'node:os';

// From: https://github.com/sindresorhus/slash/blob/98b618f5a3bfcb5dd374b204868818845b87bb2f/index.js#L1-9
const enforceForwardSlashes = (fileOrFolder) => {
    const isExtendedLengthPath = fileOrFolder.startsWith(`\\\\?\\`); // See https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file#win32-file-namespaces:~:text=file%20I/O%2C-,the%20%22%5C%5C%3F%5C%22%20prefix,-to%20a%20path
    if (isExtendedLengthPath) {
        return fileOrFolder.replaceAll(`/`, `\\`);
    }
    return fileOrFolder.replaceAll(`\\`, `/`);
};
const cleanPath = (fileOrFolder) => {
    let result = enforceForwardSlashes(fileOrFolder);
    // Check if first symbol is a lowercase letter
    const firstSymbol = result[0];
    const isFirstSymbolLowercase = firstSymbol >= `a` && firstSymbol <= `z`;
    if (isFirstSymbolLowercase) {
        if (result.startsWith(`${firstSymbol}:/`)) {
            result = `${firstSymbol.toUpperCase()}:/${result.slice(3)}`;
        }
    }
    else if (result.length >= 4) {
        const driveSymbol = result[4];
        const isDriveSymbolLowercase = driveSymbol >= `a` && driveSymbol <= `z`;
        if (isDriveSymbolLowercase) {
            if (result.startsWith(`\\\\?\\${driveSymbol}:\\`)) {
                result = `\\\\?\\${driveSymbol.toUpperCase()}:${result.slice(6)}`;
            }
        }
    }
    return result;
};

const normalize = (fileOrFolder) => {
    return cleanPath(path$1.normalize(fileOrFolder));
};
const join = (...pathSegments) => {
    return cleanPath(path$1.join(...pathSegments));
};
const resolve = (...pathSegments) => {
    return cleanPath(path$1.resolve(...pathSegments));
};
const isAbsolute = (fileOrFolder) => {
    fileOrFolder = cleanPath(fileOrFolder);
    return path$1.isAbsolute(fileOrFolder);
};
const relative = (from, to) => {
    return cleanPath(path$1.relative(from, to));
};
const dirname = (fileOrFolder) => {
    return cleanPath(path$1.dirname(fileOrFolder));
};
const basename = (fileOrFolder, suffix) => {
    return cleanPath(path$1.basename(fileOrFolder, suffix));
};
const extname = (fileOrFolder) => {
    return cleanPath(path$1.extname(fileOrFolder));
};
const parse = (fileOrFolder) => {
    const data = path$1.parse(fileOrFolder);
    data.root = cleanPath(data.root);
    data.dir = cleanPath(data.dir);
    data.base = cleanPath(data.base);
    data.ext = cleanPath(data.ext);
    data.name = cleanPath(data.name);
    return data;
};
const format = (fileOrFolderObject) => {
    return cleanPath(path$1.format(fileOrFolderObject));
};
const toNamespacedPath = (fileOrFolder) => {
    return cleanPath(path$1.toNamespacedPath(fileOrFolder));
};

const hasSlash = (fileOrFolder) => {
    const hasForwardSlash = fileOrFolder.includes(`/`);
    if (hasForwardSlash) {
        return true;
    }
    const hasBackwardSlash = fileOrFolder.includes(`\\`);
    if (hasBackwardSlash) {
        return true;
    }
    return false;
};
const isName = (fileOrFolder) => {
    return !hasSlash(fileOrFolder);
};
const stem = (fileOrFolder) => {
    const fileName = path$1.basename(fileOrFolder);
    const dotIndex = fileName.lastIndexOf(`.`);
    if (dotIndex === -1) {
        return fileName;
    }
    return fileName.slice(0, dotIndex);
};
const extension = (fileOrFolder) => {
    const fileName = path$1.basename(fileOrFolder);
    const dotIndex = fileName.lastIndexOf(`.`);
    if (dotIndex === -1) {
        return;
    }
    return fileName.slice(dotIndex + 1);
};
const indexBeforeExtension = (fileOrFolder) => {
    const dotIndex = fileOrFolder.lastIndexOf(`.`);
    if (dotIndex === -1) {
        return;
    }
    return dotIndex;
};
const withoutExtension$1 = (fileOrFolder) => {
    const inputIndexBeforeExtension = indexBeforeExtension(fileOrFolder);
    if (inputIndexBeforeExtension === undefined) {
        return fileOrFolder;
    }
    return fileOrFolder.slice(0, inputIndexBeforeExtension);
};
const indexAfterParent = (fileOrFolder) => {
    const forwardParentIndex = fileOrFolder.lastIndexOf(`/`);
    if (forwardParentIndex !== -1) {
        return forwardParentIndex + 1;
    }
    const backwardParentIndex = fileOrFolder.lastIndexOf(`\\`);
    if (backwardParentIndex !== -1) {
        return backwardParentIndex + 1;
    }
};
const indexBeforeName = (fileOrFolder) => {
    const forwardParentIndex = fileOrFolder.lastIndexOf(`/`);
    if (forwardParentIndex !== -1) {
        return forwardParentIndex + 1;
    }
    const backwardParentIndex = fileOrFolder.lastIndexOf(`\\`);
    if (backwardParentIndex !== -1) {
        return backwardParentIndex + 1;
    }
    return 0;
};
const isDotFile = (fileOrFolder) => {
    const beforeNameIndex = indexBeforeName(fileOrFolder);
    const firstNameCharacter = fileOrFolder[beforeNameIndex];
    return firstNameCharacter === `.`;
};
const addSuffix$1 = (fileOrFolder, suffix) => {
    const dotIndex = indexBeforeExtension(fileOrFolder);
    if (dotIndex === -1) {
        return fileOrFolder + suffix;
    }
    const fileBase = fileOrFolder.slice(0, dotIndex);
    const fileExtension = fileOrFolder.slice(dotIndex);
    return `${fileBase}${suffix}${fileExtension}`;
};
const addPrefix$1 = (fileOrFolder, prefix) => {
    const beforeNameIndex = indexBeforeName(fileOrFolder);
    if (beforeNameIndex === 0) {
        return `${prefix}${fileOrFolder}`;
    }
    const folderPart = fileOrFolder.slice(0, beforeNameIndex);
    const name = fileOrFolder.slice(beforeNameIndex);
    return `${folderPart}${prefix}${name}`;
};
const replaceExtension$1 = (fileOrFolder, newExtension) => {
    const currentExtension = extension(fileOrFolder);
    if (currentExtension === undefined) {
        return `${fileOrFolder}.${newExtension}`;
    }
    if (currentExtension === newExtension) {
        return;
    }
    const fileBase = fileOrFolder.slice(0, -currentExtension.length);
    return `${fileBase}${newExtension}`;
};
const replaceStem$1 = (fileOrFolder, newStem) => {
    const beforeNameIndex = indexBeforeName(fileOrFolder);
    const beforeExtensionIndex = indexBeforeExtension(fileOrFolder);
    if (beforeNameIndex === 0 && beforeExtensionIndex === undefined) {
        return newStem;
    }
    const folderPart = fileOrFolder.slice(0, beforeNameIndex);
    if (beforeExtensionIndex === undefined) {
        return `${folderPart}${newStem}`;
    }
    const fileExtension = fileOrFolder.slice(beforeExtensionIndex);
    return `${folderPart}${newStem}${fileExtension}`;
};
const parentName = (fileOrFolder) => {
    const beforeNameIndex = indexBeforeName(fileOrFolder);
    if (beforeNameIndex === 0) {
        return;
    }
    const folderPart = fileOrFolder.slice(0, beforeNameIndex - 1);
    return path$1.basename(folderPart);
};

const withoutExtension = fileOrFolder => {
    const fileOrFolderNormalized = cleanPath(fileOrFolder);
    return withoutExtension$1(fileOrFolderNormalized);
};
const addSuffix = (fileOrFolder, suffix) => {
    const fileOrFolderNormalized = cleanPath(fileOrFolder);
    return addSuffix$1(fileOrFolderNormalized, suffix);
};
const addPrefix = (fileOrFolder, prefix) => {
    const fileOrFolderNormalized = cleanPath(fileOrFolder);
    return addPrefix$1(fileOrFolderNormalized, prefix);
};
const replaceExtension = (fileOrFolder, newExtension) => {
    const fileOrFolderNormalized = cleanPath(fileOrFolder);
    return replaceExtension$1(fileOrFolderNormalized, newExtension);
};
const replaceStem = (fileOrFolder, newStem) => {
    const fileOrFolderNormalized = cleanPath(fileOrFolder);
    return replaceStem$1(fileOrFolderNormalized, newStem);
};

const folderFromUrl$1 = (url) => {
    const file = fileURLToPath(url);
    return path$1.dirname(file);
};

const folderFromUrl = url => {
    const result = folderFromUrl$1(url);
    const resultNormalized = cleanPath(result);
    return resultNormalized;
};

const getRoamingAppdataFolder = () => {
    if (process.platform === `win32`) {
        return process.env.APPDATA ?? process.env.LOCALAPPDATA ?? path$1.join(os.homedir(), `AppData`, `Roaming`);
    }
    if (process.platform === `darwin`) {
        return path$1.join(os.homedir(), `Library`, `Application Support`);
    }
    return path$1.join(os.homedir(), `.config`);
};
const getLocalAppdataFolder = () => {
    if (process.platform === `win32`) {
        return process.env.LOCALAPPDATA ?? process.env.APPDATA ?? path$1.join(os.homedir(), `AppData`, `Local`);
    }
    if (process.platform === `darwin`) {
        return path$1.join(os.homedir(), `Library`, `Application Support`);
    }
    return path$1.join(os.homedir(), `.local`, `share`);
};

const fromHome$1 = (...segments) => {
    return path$1.join(os.homedir(), ...segments);
};
const fromAppdataLocal$1 = (...segments) => {
    const localAppDataFolder = getLocalAppdataFolder();
    const folder = path$1.join(localAppDataFolder, ...segments);
    return folder;
};
const fromAppdataRoaming$1 = (...segments) => {
    const roamingAppDataFolder = getRoamingAppdataFolder();
    const folder = path$1.join(roamingAppDataFolder, ...segments);
    return folder;
};
const fromTemp$1 = (...segments) => {
    const folder = path$1.join(os.tmpdir(), ...segments);
    return folder;
};

const fromHome = (...segments) => {
    const result = fromHome$1(...segments);
    const resultNormalized = cleanPath(result);
    return resultNormalized;
};
const fromAppdataLocal = (...segments) => {
    const result = fromAppdataLocal$1(...segments);
    const resultNormalized = cleanPath(result);
    return resultNormalized;
};
const fromAppdataRoaming = (...segments) => {
    const result = fromAppdataRoaming$1(...segments);
    const resultNormalized = cleanPath(result);
    return resultNormalized;
};
const fromTemp = (...segments) => {
    const result = fromTemp$1(...segments);
    const resultNormalized = cleanPath(result);
    return resultNormalized;
};

const lib = /*#__PURE__*/Object.freeze({
    __proto__: null,
    addPrefix,
    addSuffix,
    basename,
    dirname,
    extension,
    extname,
    folderFromUrl,
    format,
    fromAppdataLocal,
    fromAppdataRoaming,
    fromHome,
    fromTemp,
    hasSlash,
    indexAfterParent,
    indexBeforeExtension,
    indexBeforeName,
    isAbsolute,
    isDotFile,
    isName,
    join,
    normalize,
    parentName,
    parse,
    relative,
    replaceExtension,
    replaceStem,
    resolve,
    stem,
    toNamespacedPath,
    withoutExtension
});

const path = Object.assign(cleanPath, lib);

export { addPrefix, addSuffix, basename, cleanPath, path as default, dirname, enforceForwardSlashes, extension, extname, folderFromUrl, format, fromAppdataLocal, fromAppdataRoaming, fromHome, fromTemp, hasSlash, indexAfterParent, indexBeforeExtension, indexBeforeName, isAbsolute, isDotFile, isName, join, normalize, parentName, parse, path, relative, replaceExtension, replaceStem, resolve, stem, toNamespacedPath, withoutExtension };
