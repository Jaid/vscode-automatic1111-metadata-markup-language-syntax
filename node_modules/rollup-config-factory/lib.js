import * as path from 'forward-slash-path';
import fs from 'fs-extra';
import * as lodash from 'lodash-es';
import { rollup } from 'rollup';
import { SyncWaterfallHook, AsyncSeriesHook, AsyncSeriesWaterfallHook } from 'tapable';
import { normalizePkg } from 'zeug';
import makeDebug from 'debug';
import commonjsPlugin from '@rollup/plugin-commonjs';
import * as immer from 'immer';
import { findUp } from 'find-up';
import { globby } from 'globby';
import jsonPlugin from '@rollup/plugin-json';
import yamlPlugin from '@rollup/plugin-yaml';
import terserPlugin from '@rollup/plugin-terser';
import publishimo from 'publishimo';
import { nodeResolve } from '@rollup/plugin-node-resolve';
import { generateDtsBundle } from 'dts-bundle-generator';

const debug = makeDebug(`rollup-config-factory`);

class CommonjsPlugin {
    options;
    constructor(options = {}) {
        this.options = {
            ...options,
        };
    }
    apply(builder, hooks) {
        hooks.build.tap(CommonjsPlugin.name, () => {
            /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
            // @ts-ignore ts(2345)
            builder.addRollupPlugin(commonjsPlugin);
        });
    }
}

const addExportToPkg = (pkg, exportValue, exportKind = `default`, exportPath = `.`) => {
    return immer.produce(pkg, draft => {
        if (typeof draft.exports === `string`) {
            draft.exports = {
                ".": draft.exports,
            };
        }
        if (typeof draft.exports?.[`.`] === `string`) {
            draft.exports[`.`] = {
                default: draft.exports[`.`],
            };
        }
        if (!draft.exports || typeof draft.exports !== `object`) {
            draft.exports = {};
        }
        if (!draft.exports[exportPath] || typeof draft.exports[exportPath] !== `object`) {
            draft.exports[exportPath] = {};
        }
        const exportsForPath = draft.exports[exportPath];
        exportsForPath[exportKind] = exportValue;
        /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
        // @ts-ignore ts(2615)
        return draft;
    });
};

const entryFileNamesProduction = chunkInfo => {
    if (chunkInfo.name === `index`) {
        return `lib.js`;
    }
    return `[name].js`;
};
class CommonPlugin {
    options;
    constructor(options = {}) {
        this.options = {
            ...options,
        };
    }
    apply(builder, hooks) {
        hooks.build.tapPromise(CommonPlugin.name, async () => {
            /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
            // @ts-ignore ts(2615)
            builder.setDefault(`output.generatedCode.arrowFunctions`, true);
            builder.setDefault(`output.generatedCode.constBindings`, true);
            builder.setDefault(`output.generatedCode.objectShorthand`, true);
            builder.setDefault(`output.entryFileNames`, entryFileNamesProduction);
        });
        hooks.buildProduction.tap(CommonPlugin.name, () => {
            builder.setDefault(`output.sourcemap`, `hidden`);
        });
        hooks.buildDevelopment.tap(CommonPlugin.name, () => {
            builder.setDefault(`output.sourcemap`, `hidden`);
        });
        hooks.finalizeOptions.tap(CommonPlugin.name, options => {
            if (!options.outputFolder.includes(`{{mode}}`)) {
                return options;
            }
            const mode = options.env === `production` ? `production` : `development`;
            return {
                ...options,
                outputFolder: options.outputFolder.replaceAll(`{{mode}}`, mode),
            };
        });
        /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
        // @ts-ignore ts(2615)
        hooks.processPkg.tap(CommonPlugin.name, pkg => {
            const pkgWithEsExport = addExportToPkg(pkg, `./lib.js`, `import`);
            const pkgWithDefaultExport = addExportToPkg(pkgWithEsExport, `./lib.js`);
            return pkgWithDefaultExport;
        });
    }
}

var _a;
const defaultOptions$8 = {
    filterStrategy: `node_modules`,
};
class ExternalsPlugin {
    static #getPackageNameFromSource(source) {
        const moduleParts = source.split(`/`);
        const relevantLength = source.startsWith(`@`) ? 2 : 1;
        if (moduleParts.length < relevantLength) {
            return moduleParts[0];
        }
        const relevantParts = moduleParts.slice(0, relevantLength);
        return relevantParts.join(`/`);
    }
    options;
    #builder;
    #cache = new Set;
    constructor(options = {}) {
        this.options = {
            ...defaultOptions$8,
            ...options,
        };
    }
    apply(builder, hooks) {
        this.#builder = builder;
        hooks.build.tapPromise(_a.name, async () => {
            const filter = await this.#prepareFilter();
            builder.set(`external`, filter);
        });
    }
    #externalsFilterByCache(source, importer, isResolved) {
        const sourcePackage = _a.#getPackageNameFromSource(source);
        return this.#cache.has(sourcePackage);
    }
    async #prepareFilter() {
        if (this.options.filterStrategy === `pkg`) {
            return this.#prepareFilterByPkg();
        }
        return this.#prepareFilterByNodeModules();
    }
    async #prepareFilterByNodeModules() {
        const nodeModulesFolder = await findUp(`node_modules`, {
            type: `directory`,
        });
        if (!nodeModulesFolder) {
            return;
        }
        const nodeModulesFolderNames = await globby(`*`, {
            onlyDirectories: true,
            cwd: nodeModulesFolder,
        });
        for (const folderName of nodeModulesFolderNames) {
            if (folderName.startsWith(`.`)) {
                continue;
            }
            if (folderName.startsWith(`@`)) {
                const subFolderNames = await globby(`*`, {
                    onlyDirectories: true,
                    cwd: `${nodeModulesFolder}/${folderName}`,
                });
                for (const subFolderName of subFolderNames) {
                    this.#cache.add(`${folderName}/${subFolderName}`);
                }
                continue;
            }
            this.#cache.add(folderName);
        }
        return this.#externalsFilterByCache.bind(this);
    }
    async #prepareFilterByPkg() {
        if (!this.#builder?.pkg) {
            return;
        }
        const dependencyFields = [`dependencies`, `peerDependencies`, `optionalDependencies`, `devDependencies`];
        for (const field of dependencyFields) {
            for (const key of Object.keys(this.#builder.pkg[field] ?? {})) {
                this.#cache.add(key);
            }
        }
        return this.#externalsFilterByCache.bind(this);
    }
}
_a = ExternalsPlugin;

const defaultOptions$7 = {
    jsonOptions: {
        preferConst: true,
        indent: `  `,
    },
};
class LoadAssetsPlugin {
    options;
    constructor(options = {}) {
        this.options = {
            ...defaultOptions$7,
            ...options,
        };
    }
    apply(builder, hooks) {
        hooks.build.tap(LoadAssetsPlugin.name, () => {
            if (this.options.jsonOptions !== false) {
                /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
                // @ts-ignore ts(2345)
                builder.addRollupPlugin(jsonPlugin, this.options.jsonOptions);
            }
            if (this.options.yamlOptions !== false) {
                /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
                // @ts-ignore ts(2345)
                builder.addRollupPlugin(yamlPlugin, this.options.yamlOptions);
            }
        });
    }
}

const outputEcmaVersion = 2020;
const defaultTerserOptions = {
    module: true,
    ecma: outputEcmaVersion,
    compress: {
        passes: 100,
        unsafe_comps: true,
        unsafe_math: true,
        unsafe_regexp: true,
        unsafe_undefined: true,
        booleans_as_integers: true,
        unsafe_Function: true,
        unsafe_methods: true,
        unsafe_proto: true,
        ecma: outputEcmaVersion,
    },
    format: {
        ecma: outputEcmaVersion,
        semicolons: false,
        wrap_func_args: false,
    },
};
const aggressiveTerserOptionsAdditions = {
    compress: {
        keep_fargs: false,
        hoist_funs: true,
        pure_new: true,
        unsafe_arrows: true,
    },
};
const defaultOptions$6 = {
    terserPreset: `default`,
};
const map = new Map([
    [`default`, defaultTerserOptions],
    [`aggressive`, lodash.defaultsDeep(aggressiveTerserOptionsAdditions, defaultTerserOptions)],
]);
class MinifyPlugin {
    options;
    #getTerserOptionsPreset = () => {
        return map.get(this.options.terserPreset) ?? defaultTerserOptions;
    };
    #makeTerserOptions = () => {
        const preset = this.#getTerserOptionsPreset();
        if (this.options.terserOptions === undefined) {
            return preset;
        }
        const options = {
            ...preset,
            ...this.options.terserOptions,
        };
        return options;
    };
    #makeTerserPluginOptions = () => {
        const options = this.#makeTerserOptions();
        if (this.options.terserPluginOptions === undefined) {
            return options;
        }
        return {
            ...options,
            ...this.options.terserPluginOptions,
        };
    };
    constructor(options = {}) {
        this.options = {
            ...defaultOptions$6,
            ...options,
        };
    }
    apply(builder, hooks) {
        hooks.buildProduction.tapPromise(MinifyPlugin.name, async () => {
            const pluginOptions = this.#makeTerserPluginOptions();
            /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
            // @ts-ignore ts(2345)
            builder.addRollupPlugin(terserPlugin, pluginOptions);
        });
    }
}

const getEntry$1 = (plugin) => {
    for (const id of plugin.getModuleIds()) {
        const moduleInfo = plugin.getModuleInfo(id);
        if (!moduleInfo) {
            continue;
        }
        if (!moduleInfo.isEntry) {
            continue;
        }
        const isTypescriptRegex = /\.[cm]?tsx?$/;
        if (!isTypescriptRegex.test(moduleInfo.id)) {
            continue;
        }
        return moduleInfo.id;
    }
};
const defaultOptions$5 = {
    pretty: false,
};
function publishimoPlugin$1(pluginOptions = {}) {
    const options = {
        ...defaultOptions$5,
        ...pluginOptions,
    };
    return {
        name: `dts-bundle-generator`,
        async generateBundle() {
            const entry = getEntry$1(this);
            if (!entry) {
                throw new Error(`No entry found, searched in ${[...this.getModuleIds()].length} modules`);
            }
            /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
            // @ts-ignore ts(2339)
            const publishimoResult = await publishimo.default(options.publishimoOptions);
            const outputPkg = {
                ...publishimoResult.generatedPkg,
                ...options.extend,
            };
            const json = options.pretty ? JSON.stringify(outputPkg, null, 2) : JSON.stringify(outputPkg);
            this.emitFile({
                type: `asset`,
                fileName: `package.json`,
                source: json,
            });
        },
    };
}

const defaultOptions$4 = {
    includeFields: [
        `dependencies`,
        `peerDependencies`,
        `peerDependenciesMeta`,
        `optionalDependencies`,
        `exports`,
    ],
};
class PkgPlugin {
    options;
    constructor(options = {}) {
        this.options = {
            ...defaultOptions$4,
            ...options,
        };
    }
    apply(builder, hooks) {
        hooks.buildProduction.tap(PkgPlugin.name, () => {
            const publishimoOptions = {
                pkg: builder.pkg,
                fetchGithub: false,
                includeFields: [
                    `dependencies`,
                    `peerDependencies`,
                    `peerDependenciesMeta`,
                    `optionalDependencies`,
                    `exports`,
                ],
            };
            builder.addRollupPlugin(publishimoPlugin$1, {
                publishimoOptions,
                extend: {
                    type: `module`,
                },
            });
        });
    }
}

const getEntry = (plugin) => {
    for (const id of plugin.getModuleIds()) {
        const moduleInfo = plugin.getModuleInfo(id);
        if (!moduleInfo) {
            continue;
        }
        if (!moduleInfo.isEntry) {
            continue;
        }
        const isTypescriptRegex = /\.[cm]?tsx?$/;
        if (!isTypescriptRegex.test(moduleInfo.id)) {
            continue;
        }
        return moduleInfo.id;
    }
};
const defaultOptions$3 = {
    sort: true,
    generatorBanner: false,
    inlinedImports: [
        `type-fest`,
        `ts-toolbelt`,
        `ts-essentials`,
        `utility-types`,
        `more-types`,
    ],
    outputFile: `types.d.ts`,
};
function dtsBundleGeneratorPlugin(pluginOptions = {}) {
    const options = {
        ...defaultOptions$3,
        ...pluginOptions,
    };
    return {
        name: `dts-bundle-generator`,
        async generateBundle() {
            const entry = getEntry(this);
            if (!entry) {
                throw new Error(`No entry found, searched in ${[...this.getModuleIds()].length} modules`);
            }
            const generateDtsBundleOptions = {
                preferredConfigPath: options.tsConfigFile,
            };
            const generateDtsBundleEntryOptions = {
                output: {
                    sortNodes: options.sort,
                    noBanner: !options.generatorBanner,
                    exportReferencedTypes: false,
                },
                libraries: {
                    inlinedLibraries: options.inlinedImports,
                },
            };
            const dtsEntry = {
                ...generateDtsBundleEntryOptions,
                filePath: entry,
            };
            const dtsOutputs = generateDtsBundle([dtsEntry], generateDtsBundleOptions);
            if (dtsOutputs.length === 0) {
                return;
            }
            if (dtsOutputs.length > 1) {
                throw new Error(`Expected only one dts output, but got ${dtsOutputs.length}`);
            }
            this.emitFile({
                type: `asset`,
                fileName: options.outputFile,
                source: dtsOutputs[0],
            });
        },
    };
}

const defaultOptions$2 = {
    compiler: `typescript`,
    rewriteEntry: true,
    declarationEmitter: `dts-bundle-generator`,
    declarationOnlyForProduction: true,
    declarationFile: `lib.d.ts`,
};
class TypescriptPlugin {
    options;
    pkg;
    tsconfig;
    #builder;
    constructor(options = {}) {
        this.options = {
            ...defaultOptions$2,
            ...options,
        };
    }
    apply(builder, hooks) {
        this.#builder = builder;
        hooks.build.tapPromise(TypescriptPlugin.name, async () => {
            const resolverOptions = {
                extensions: [`.js`, `.ts`],
            };
            builder.addRollupPlugin(nodeResolve, resolverOptions);
            await this.#addCompilerPlugin();
        });
        hooks.finalizeConfig.tapPromise(TypescriptPlugin.name, async (config) => {
            if (!this.options.rewriteEntry) {
                return config;
            }
            if (typeof config.input === `string`) {
                if (config.input.endsWith(`.js`)) {
                    /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
                    // @ts-ignore ts(2615)
                    builder.set(`input`, `${config.input.slice(0, -3)}.ts`);
                }
            }
            else {
                builder.setDefault(`input`, builder.fromContextFolder(`src/index.ts`));
            }
            return config;
        });
        /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
        // @ts-ignore ts(2615)
        hooks.processPkg.tap(TypescriptPlugin.name, pkg => {
            if (this.options.declarationOnlyForProduction && !this.#builder.isProduction) {
                return pkg;
            }
            const pkgModified = addExportToPkg(pkg, `./${this.options.declarationFile}`, `types`);
            return {
                ...pkgModified,
                types: this.options.declarationFile,
            };
        });
        hooks.buildProduction.tapPromise(TypescriptPlugin.name, async () => {
            await this.#addDtsEmitterPlugin();
        });
        hooks.buildDevelopment.tapPromise(TypescriptPlugin.name, async () => {
            if (!this.options.declarationOnlyForProduction) {
                await this.#addDtsEmitterPlugin();
            }
        });
    }
    async #addCompilerPlugin() {
        if (this.options.compiler === `rollup-plugin-ts`) {
            await this.#addTsPlugin();
        }
        else if (this.options.compiler === `sucrase`) {
            await this.#addSucrasePlugin();
        }
        else if (this.options.compiler === `swc`) {
            await this.#addSwcPlugin();
        }
        else {
            await this.#addTypescriptPlugin();
        }
    }
    async #addDtsBundleGeneratorPlugin() {
        const options = this.#getDtsBundleGeneratorPluginOptions();
        this.#builder.addRollupPlugin(dtsBundleGeneratorPlugin, options);
    }
    async #addDtsEmitterPlugin() {
        if (this.options.declarationEmitter === `dts-bundle-generator`) {
            await this.#addDtsBundleGeneratorPlugin();
        }
        else if (this.options.declarationEmitter === `rollup-plugin-dts`) {
            await this.#addDtsPlugin();
        }
    }
    async #addDtsPlugin() {
        const { default: dtsPlugin } = await import('rollup-plugin-dts');
        const options = this.#getDtsPluginOptions();
        this.#builder.addRollupPlugin(dtsPlugin, options);
    }
    async #addSucrasePlugin() {
        const { default: sucrasePlugin } = await import('@rollup/plugin-sucrase');
        const options = this.#getSucrasePluginOptions();
        /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
        // @ts-ignore ts(2615)
        this.#builder.addRollupPlugin(sucrasePlugin, options);
    }
    async #addSwcPlugin() {
        const { default: swcPlugin } = await import('@rollup/plugin-swc');
        const options = this.#getSwcPluginOptions();
        /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
        // @ts-ignore ts(2615)
        this.#builder.addRollupPlugin(swcPlugin, options);
    }
    async #addTsPlugin() {
        const { default: tsPlugin } = await import('rollup-plugin-ts');
        const options = this.#getTsPluginOptions();
        this.#builder.addRollupPlugin(tsPlugin, options);
    }
    async #addTypescriptPlugin() {
        const { default: typescriptPlugin } = await import('@rollup/plugin-typescript');
        const options = this.#getTypescriptPluginOptions();
        /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
        // @ts-ignore ts(2615)
        this.#builder.addRollupPlugin(typescriptPlugin, options);
    }
    #getDtsBundleGeneratorPluginOptions() {
        const pluginOptions = {
            tsConfigFile: this.#builder.fromContextFolder(`tsconfig.json`),
            outputFile: this.options.declarationFile,
        };
        return pluginOptions;
    }
    #getDtsPluginOptions() {
        const compilerOptions = this.#getTypescriptCompilerOptions();
        const pluginOptions = {
            respectExternal: false,
            compilerOptions: {
                ...compilerOptions,
                declaration: true,
            },
        };
        return pluginOptions;
    }
    #getSucrasePluginOptions() {
        const pluginOptions = {
            production: this.#builder.isProduction,
            exclude: [`node_modules/**`],
            transforms: [`typescript`],
        };
        return pluginOptions;
    }
    #getSwcPluginOptions() {
        const pluginOptions = {
            swc: {
                root: this.#builder.contextFolder,
                cwd: this.#builder.contextFolder,
                envName: this.#builder.isProduction ? `production` : `development`,
                sourceMaps: true,
                jsc: {
                    parser: {
                        syntax: `typescript`,
                        tsx: true,
                        dynamicImport: true,
                        decorators: true,
                    },
                    baseUrl: this.#builder.contextFolder,
                    paths: this.#builder.tsconfig?.compilerOptions?.paths,
                    transform: {
                        legacyDecorator: true,
                        decoratorMetadata: true,
                    },
                    target: `es2022`,
                    keepClassNames: true,
                },
            },
        };
        return pluginOptions;
    }
    #getTsPluginOptions() {
        const compilerOptions = this.#getTypescriptCompilerOptions();
        const pluginOptions = {
            tsconfig: {
                fileName: this.#builder.fromContextFolder(`tsconfig.json`),
                hook: (loadedConfig) => {
                    // @ts-expect-error
                    const tsConfig = {
                        ...loadedConfig,
                        ...compilerOptions,
                    };
                    return tsConfig;
                },
            },
            transpileOnly: true,
            transpiler: `typescript`,
            cwd: this.#builder.contextFolder,
            browserslist: false,
        };
        return pluginOptions;
    }
    #getTypescriptCompilerOptions() {
        return {
            module: `esnext`,
            moduleResolution: `bundler`,
            target: `es2022`,
            skipLibCheck: true,
            outDir: this.#builder.fromOutputFolder(`ts`),
            rootDir: this.#builder.contextFolder,
            baseUrl: this.#builder.contextFolder,
            strict: false,
            composite: false,
            declaration: false,
        };
    }
    #getTypescriptOptions() {
        const compilerOptions = this.#getTypescriptCompilerOptions();
        return {
            compilerOptions: {
                ...compilerOptions,
            },
        };
    }
    #getTypescriptPluginOptions() {
        const typescriptOptions = this.#getTypescriptOptions();
        return {
            ...typescriptOptions,
            tsconfig: this.#builder.fromContextFolder(`tsconfig.json`),
            cacheDir: this.#builder.fromContextFolder(`temp`, `.rollup_cache`),
        };
    }
}

const nodeEnv = process.env.NODE_ENV ?? `development`;
const defaultOptions$1 = {
    contextFolder: `.`,
    env: nodeEnv,
    outputFolder: `dist/package/${process.env.npm_package_name ?? `default`}/${nodeEnv}`,
    useDefaultPlugins: true,
    minify: false,
    externals: `node_modules`,
};
class ConfigBuilder {
    contextFolder;
    hooks = {
        finalizeOptions: new SyncWaterfallHook([`options`]),
        init: new AsyncSeriesHook([`configBuilder`]),
        processPkg: new AsyncSeriesWaterfallHook([`pkg`]),
        processTsconfig: new AsyncSeriesWaterfallHook([`tsconfig`]),
        beforeBuild: new AsyncSeriesHook,
        build: new AsyncSeriesHook,
        buildDevelopment: new AsyncSeriesHook,
        buildProduction: new AsyncSeriesHook,
        buildStatic: new AsyncSeriesHook,
        buildWatch: new AsyncSeriesHook,
        afterBuild: new AsyncSeriesHook,
        finalizeConfig: new AsyncSeriesWaterfallHook([`config`]),
    };
    options;
    outputFolder;
    #isProduction;
    #isWatch = false;
    #pkg;
    #rollupConfig = {};
    #tsconfig;
    constructor(options = {}) {
        const mergedOptions = {
            ...defaultOptions$1,
            ...options,
        };
        if (mergedOptions.useDefaultPlugins) {
            this.addBuilderPlugin(new CommonjsPlugin);
        }
        if (mergedOptions.externals) {
            this.addBuilderPlugin(new ExternalsPlugin);
        }
        if (mergedOptions.useDefaultPlugins) {
            this.addBuilderPlugin(new TypescriptPlugin);
        }
        for (const plugin of mergedOptions.plugins ?? []) {
            this.addBuilderPlugin(plugin);
        }
        if (mergedOptions.minify) {
            const plugin = mergedOptions.minify === `aggressive` ? new MinifyPlugin({ terserPreset: `aggressive` }) : new MinifyPlugin;
            this.addBuilderPlugin(plugin);
        }
        if (mergedOptions.useDefaultPlugins) {
            this.addBuilderPlugin(new LoadAssetsPlugin);
            this.addBuilderPlugin(new PkgPlugin);
            this.addBuilderPlugin(new CommonPlugin);
        }
        this.options = this.hooks.finalizeOptions.call(mergedOptions);
        this.#isProduction = this.options.env === `production`;
        this.outputFolder = path.resolve(this.options.outputFolder);
        this.contextFolder = path.resolve(this.options.contextFolder);
    }
    get isDevelopment() {
        return !this.#isProduction;
    }
    get isProduction() {
        return this.#isProduction;
    }
    get isStatic() {
        return !this.#isWatch;
    }
    get isWatch() {
        return this.#isWatch;
    }
    get pkg() {
        return this.#pkg;
    }
    get rollupConfig() {
        return this.#rollupConfig;
    }
    get tsconfig() {
        return this.#tsconfig;
    }
    addBuilderPlugin(plugin) {
        plugin.apply(this, this.hooks);
    }
    addRollupPlugin(plugin, options) {
        if (options !== undefined) {
            const createdPlugin = plugin(options);
            debug(`Adding plugin %s with options %O`, createdPlugin.name, options);
            this.append(`plugins`, createdPlugin);
        }
        else {
            const createdPlugin = plugin();
            debug(`Adding plugin %s`, createdPlugin.name);
            this.append(`plugins`, createdPlugin);
        }
    }
    append(key, value) {
        const array = this.getEnsuredArray(key);
        array.push(value);
    }
    appendUnique(key, value) {
        const array = this.getEnsuredArray(key);
        if (!array.includes(value)) {
            array.push(value);
        }
    }
    async build() {
        await this.hooks.init.promise(this);
        const processPkgJob = this.#processPkg();
        const processTsconfigJob = this.#processTsconfig();
        await Promise.all([processPkgJob, processTsconfigJob]);
        await this.hooks.beforeBuild.promise();
        if (this.isDevelopment) {
            await this.hooks.buildDevelopment.promise();
        }
        else {
            await this.hooks.buildProduction.promise();
        }
        if (this.isWatch) {
            await this.hooks.buildWatch.promise();
        }
        else {
            await this.hooks.buildStatic.promise();
        }
        await this.hooks.build.promise();
        this.setDefault(`output.dir`, this.outputFolder);
        this.setDefault(`input`, this.fromContextFolder(`src`, `index.js`));
        await this.hooks.afterBuild.promise();
        const config = this.hooks.finalizeConfig.promise(this.#rollupConfig);
        return config;
    }
    async compile() {
        let bundle;
        let output;
        try {
            bundle = await rollup(this.#rollupConfig);
            const outputOptions = this.#rollupConfig.output;
            output = await bundle.write(outputOptions);
            return {
                bundle,
                output,
            };
        }
        catch (error) {
            throw error;
        }
        finally {
            await bundle?.close();
        }
    }
    fromContextFolder(...pathSegments) {
        return path.join(this.contextFolder, ...pathSegments);
    }
    fromOutputFolder(...pathSegments) {
        return path.join(this.outputFolder, ...pathSegments);
    }
    get(key) {
        return lodash.get(this.#rollupConfig, key);
    }
    getEnsuredArray(key) {
        const array = this.get(key);
        if (Array.isArray(array)) {
            return array;
        }
        const value = [];
        this.set(key, value);
        return value;
    }
    has(key) {
        return lodash.has(this.#rollupConfig, key);
    }
    prepend(key, value) {
        const array = this.getEnsuredArray(key);
        array.unshift(value);
    }
    prependUnique(key, value) {
        const array = this.getEnsuredArray(key);
        if (!array.includes(value)) {
            array.unshift(value);
        }
    }
    set(key, value) {
        lodash.set(this.#rollupConfig, key, value);
    }
    setDefault(key, value) {
        if (!this.has(key)) {
            this.set(key, value);
        }
    }
    async #processPkg() {
        const file = this.fromContextFolder(`package.json`);
        const fileExists = await fs.pathExists(file);
        if (!fileExists) {
            return;
        }
        const pkg = await fs.readJson(file);
        const pkgNormalized = normalizePkg(pkg);
        const pkgModified = await this.hooks.processPkg.promise(pkgNormalized);
        const pkgModifiedNormalized = normalizePkg(pkgModified);
        this.#pkg = pkgModifiedNormalized;
    }
    async #processTsconfig() {
        const file = this.fromContextFolder(`tsconfig.json`);
        const fileExists = await fs.pathExists(file);
        if (!fileExists) {
            return;
        }
        const tsconfig = await fs.readJson(file);
        this.#tsconfig = await this.hooks.processTsconfig.promise(tsconfig);
    }
}

const buildConfig = async (options) => {
    const configBuilder = new ConfigBuilder(options);
    const rollupConfig = await configBuilder.build();
    return rollupConfig;
};

const defaultOptions = {
    content: ``,
};
function publishimoPlugin(pluginOptions) {
    if (!pluginOptions.name) {
        throw new Error(`option “name” is required for Rollup plugin emit-file`);
    }
    const options = {
        ...defaultOptions,
        ...pluginOptions,
    };
    return {
        name: `emit-file`,
        async generateBundle() {
            const source = options.content;
            this.emitFile({
                type: `asset`,
                fileName: `package.json`,
                source,
            });
        },
    };
}

export { CommonPlugin, CommonjsPlugin, ConfigBuilder, ExternalsPlugin, LoadAssetsPlugin, MinifyPlugin, PkgPlugin, TypescriptPlugin, buildConfig, ConfigBuilder as default, dtsBundleGeneratorPlugin as dtsBundleGenerator, publishimoPlugin as emitFile, publishimoPlugin$1 as publishimo };
