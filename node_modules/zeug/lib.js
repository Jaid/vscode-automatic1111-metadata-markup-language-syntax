import e from"@prettier/sync"
import n from"format-thousands"
import t from"handlebars"
import{strict as r,AssertionError as o}from"node:assert"
import s from"debug"
import{pathToFileURL as i}from"node:url"
import*as a from"lodash-es"
import c from"yargs"
import{hideBin as m}from"yargs/helpers"
import u from"fs-extra"
import"node:console"
import l,{Document as p,Scalar as f,YAMLMap as d}from"yaml"
import g,{mapObjectSkip as h}from"map-obj"
import*as y from"immer"
import v from"normalize-package-data"
import{firstMatch as w,matches as b}from"super-regex"
const $=(e,n)=>"object"==typeof n&&null!==n?n:{[e]:n},k=e=>"string"!=typeof e?0:e.endsWith(".map"),O=(e,n)=>"string"!=typeof e?e:n?e.slice(0,-4):e,A=(e,n=k,t=O)=>{const r={}
for(const[t,o]of Object.entries(e)){const e=t,s={isActuallyDynamic:0,isDynamic:n(t,o)}
if(s.isDynamic)if(Array.isArray(o)){if(0===o.length)continue
1===o.length?s.value=o[0]:s.isActuallyDynamic=1}else s.value=o
else s.value=o
r[e]=s}const o=Object.keys(r).filter(e=>r[e].isActuallyDynamic)
return o.length?o.reduce((n,t)=>{const r=e[t]
return n.flatMap(e=>r.map(n=>[...e,n]))},[[]]).map(e=>{const n={}
for(const s of Object.keys(r)){const i=r[s],a=t(s,i.isDynamic,i.isActuallyDynamic),c=i.isActuallyDynamic?e[o.indexOf(s)]:i.value
n[a]=c}return n}):[e]},N=e=>e.replaceAll(/\W/g,"")
function _(e,n,t){const r=[]
let o
o=void 0===t?e=>e:"string"==typeof t?e=>e[t]:t
for(const[t,s]of n.entries()){const n=o(s,t)
if(n===e)return t
r.push(n)}const s=r.map(e=>e.toLowerCase()),i=e.toLowerCase(),a=s.indexOf(i)
if(-1!==a)return a
const c=N(i),m=s.findIndex(e=>N(e)===c)
return-1!==m?m:void 0}function D(e,n,t){const r=[]
let o
o=void 0===t?e=>e:"string"==typeof t?e=>e[t]:t
for(const[t,s]of n.entries()){const n=o(s,t)
if(n===e)return s
r.push(n)}const s=r.map(e=>e.toLowerCase()),i=e.toLowerCase(),a=s.indexOf(i)
if(-1!==a)return n[a]
const c=N(i),m=s.findIndex(e=>N(e)===c)
return-1!==m?n[m]:void 0}const G=n=>{const t=n.replaceAll(/^\s*[\n\r]/gm,"")
return e.format(t,{parser:"typescript",arrowParens:"avoid",bracketSameLine:1,bracketSpacing:0,embeddedLanguageFormatting:"off",jsxSingleQuote:1,printWidth:80,quoteProps:"as-needed",requirePragma:0,semi:0,singleQuote:1,tabWidth:2,trailingComma:"none"}).trim()},S=String.fromCodePoint(8239),x=e=>n(e,{seperator:S,formatFourDigits:0}),E={noEscape:1,knownHelpersOnly:1},j={knownHelpersOnly:1},F=(e=E)=>{const n=t.create(),r=n.compile
n.compile=function(n,t){return r(n,{...e,...t})}
const o=n.precompile
return n.precompile=function(n,t){return o(n,{...e,...t})},n},M=(e,n=E)=>{const t=Object.fromEntries(Object.keys(e).map(e=>[e,1])),r=F({...n,knownHelpers:t})
for(const[n,t]of Object.entries(e))r.registerHelper(n,t)
return r},C=(e=j)=>F(e),L=(e,n=j)=>M(e,n),W=(e,n)=>void 0===n?t.compile(e,E):M(n).compile(e),I=(e,n,t)=>(void 0===t?W(e):M(t).compile(e))(n),P=(e,n)=>void 0===n?t.compile(e,j):L(n).compile(e),T=(e,n,t)=>(void 0===t?P(e):L(t).compile(e))(n)
function q(e={}){return(n,t,r)=>{if(null===e.log)return r
const o=n=>{const r=e.fractionDigits??2
let o,s
0===r?(o=`${Math.trunc(n)}`,"0"===o&&(o="1")):o=n.toFixed(r),s=void 0!==e.message?e.message.replace("{function}",`${t}`).replace("{ms}",o).replace("{msRaw}",`${n}`):`${t} took ${o} ms`,void 0!==e.log?e.log(s):console.log(s)},s=r.value
return r.value=function(...e){const n=performance.now(),t=s.apply(this,e)
if(t&&"function"==typeof t.then)return t.then(e=>{const t=performance.now()
return o(t-n),e})
{const e=performance.now()
return o(e-n),t}},r}}const H={...r,greaterThan(e,n){let t
try{t=Number(e)}catch(n){throw new o({message:`Given value is not a number: ${e}`})}if(n>=t)throw new o({message:`Given number ${t} should be greater than ${n}`})},greaterThanOrEqual(e,n){let t
try{t=Number(e)}catch(n){throw new o({message:`Given value is not a number: ${e}`})}if(n>t)throw new o({message:`Given number ${t} should be at least ${n}`})},lessThan(e,n){let t
try{t=Number(e)}catch(n){throw new o({message:`Given value is not a number: ${e}`})}if(t>=n)throw new o({message:`Given number ${t} should be less than ${n}`})},lessThanOrEqual(e,n){let t
try{t=Number(e)}catch(n){throw new o({message:`Given value is not a number: ${e}`})}if(t>n)throw new o({message:`Given number ${t} should be at most ${n}`})},numberBetween(e,n,t){let r
try{r=Number(e)}catch(n){throw new o({message:`Given value is not a number: ${e}`})}if(n>r||r>t)throw new o({message:`Given number ${r} should be between ${n} and ${t}`})},notInteger(e){let n
try{n=Number(e)}catch(n){throw new o({message:`Given value is not a number: ${e}`})}if(n%1==0)throw new o({message:`Given number ${n} should not be an integer`})}},R=e=>{const n=process.env.npm_package_name
if(void 0===n)throw new Error("Cannot find package name in env var “npm_package_name”")
return s(void 0===e?n:`${n}:${e}`)},Q=async e=>{const n=process.env.MAIN_MODULE?i(process.env.MAIN_MODULE).toString():process.env.npm_package_name??e
if(!n)throw new Error("Cannot find main module path, searched in env vars “MAIN_MODULE” and “npm_package_name”")
return await import(n)},U=async e=>(await Q(e)).default,B=e=>{a.isFunction(e)&&(e={command:e}),void 0===e.strict&&(e.strict=1)
const n=c([])
n.detectLocale(0),e.strict&&n.strict(),n.parserConfiguration({"strip-aliased":1,"strip-dashed":1,...e.parserOptions}),n.scriptName(process.env.npm_package_name),n.version(process.env.npm_package_version),n.completion(),void 0!==e.options&&n.options(e.options)
const t=e=>{a.isFunction(e)?n.command("$0","",{},e):n.command(e)}
if(void 0!==e.command){if(Array.isArray(e.command))for(const n of e.command)t(n)
else t(e.command)
e.strict&&n.demandCommand()}n.help(),n.showHelpOnFail(0)
const r=e.helpWidth??100
return n.wrap(Math.min(r,n.terminalWidth())),void 0!==e.modify&&e.modify(n),async e=>{const t=e??m(process.argv)
return n.parseAsync(t)}},z=async(e,n)=>B({command:e,strict:0})(n),V={indentSeq:0,lineWidth:0,minContentWidth:0,singleQuote:1},J=(e,n)=>{const t=typeof n
if("function"!==t)return"string"===t||"number"===t||"boolean"===t||"undefined"===t||null===n?n:n instanceof RegExp?n.source:n instanceof Date?n.toISOString():n instanceof Set||n instanceof Map||Array.isArray(n)||"object"===t?n:void 0},K=(e,n)=>{if("string"!=typeof e||!e.startsWith("_"))return J(0,n)},X=e=>l.stringify(e,void 0,V),Y=e=>{const n={identify:e=>e instanceof RegExp,createNode(e,n,t){const r=n.toString(),o=new f(r)
return o.comment=" RegExp",o}},t={identify:e=>"bigint"==typeof e,createNode(e,n,t){const r=new f(n)
return r.comment=" BigInt",r}},r={identify:e=>"function"==typeof e,createNode(e,n,t){const r=new d
let o=n.toString(),s=0
try{o=G(o),s=1}catch(e){}const i=(s?`[Formatted with Prettier]\n${o}`:o).replaceAll(/^/gm," ")
if(void 0!==n.name&&""!==n.name){const e=new f(n.name)
e.comment=i,r.set("name",e)}else r.comment=i
for(const[e,t]of Object.entries(n))r.set(e,t)
return r}},o=new p(e,{anchorPrefix:"anchor",keepSourceTokens:1,logLevel:"debug",customTags:e=>[t,n,r,...e]}),s={Pair(e,n,t){const r=n.key?.value
if("string"==typeof r&&r.startsWith("_"))return l.visit.REMOVE}}
return l.visit(o,s),o.toString({...V})},Z=async(e,n)=>{const t=Y(e)
await u.outputFile(n,t)},ee=async(e,n)=>{const t=X(e)
await u.outputFile(n,t)},ne=(e={})=>(n,t)=>{const r=Object.assign({},n,e.context),o=g(n,(n,t)=>"_"===n||"$0"===n||e.keys&&!e.keys.includes(n)||"string"!=typeof t?h:(e=>e.includes("{{"))(t)?[n,I(t,r)]:h)
return console.dir(o),o},te=ne(),re=e=>y.produce(e,e=>(v(e),e)),oe=/^\s*((?<hours>\d+)\s*:)?\s*((?<minutes>\d+)\s*:)?\s*(?<seconds>(?<fullSeconds>\d+)(\.(?<secondsFractalDigits>\d+))?)\s*$/,se=e=>{const n=w(oe,e,{timeout:1e3})?.namedGroups
if(console.log(n),void 0!==n)return n},ie=e=>{const n=se(e)
if(void 0!==n)return 3600*(n.hours?Number(n.hours):0)+60*(n.minutes?Number(n.minutes):0)+Number(n.seconds)},ae=e=>{const n=se(e)
if(void 0===n)return
const t=3600*(n.hours?Number(n.hours):0)+60*(n.minutes?Number(n.minutes):0)+Number(n.fullSeconds)
return void 0===n.secondsFractalDigits?t.toString():`${t}.${n.secondsFractalDigits}`},ce=e=>{const n=ie(e)
if(void 0!==n)return Math.trunc(1e3*n)},me={matchTimeout:6e4,timeout:6e5},ue={timeout:6e5},le=(e,n,t=ue)=>w(n,e,t).namedGroups,pe=(e,n,t=me)=>{const r=b(n,e,t)
return Array.from(r,e=>e.namedGroups)},fe=(e,n,t,r=ue)=>{const o=w(n,e,r)
return o?.namedGroups[t]},de=(e,n,t,r=me)=>{const o=b(n,e,r)
return Array.from(o,e=>e.namedGroups[t])},ge=(e,n,t=0,r=ue)=>{const o=w(n,e,r)
return o?.groups[t]},he=(e,n,t=0,r=me)=>{const o=b(n,e,r)
return Array.from(o,e=>e.groups[t])}
export{H as assert,ne as createInterpolateHandlebarsMiddleware,k as defaultDynamicPredicate,O as defaultKeyMapper,$ as ensureObject,A as expandMaps,D as findGraceful,_ as findGracefulIndex,ge as findGroup,he as findGroupGlobal,fe as findNamedGroup,de as findNamedGroupGlobal,le as findNamedGroups,pe as findNamedGroupsGlobal,G as formatCode,x as formatThousands,Q as getMainModule,U as getMainModuleDefault,te as interpolateHandlebarsMiddleware,q as logExecutionTime,B as makeCli,R as makeDebug,F as makeHandlebars,W as makeHandlebarsRenderer,M as makeHandlebarsWithHelpers,C as makeHtmlHandlebars,P as makeHtmlHandlebarsRenderer,L as makeHtmlHandlebarsWithHelpers,re as normalizePkg,se as parseTimecode,I as renderHandlebars,T as renderHtmlHandlebars,J as replacer,z as runSimpleCli,K as skipUnderscoreReplacer,ce as timecodeToMs,ie as timecodeToSeconds,ae as timecodeToSecondsString,Y as toCleanYaml,Z as toCleanYamlFile,X as toYaml,ee as toYamlFile,V as yamlStringifySettings}
